「图」的基本知识
「图」大概是最接近生活的一种数据结构了，生活中各种关系图便是「图」最真实的写照。比如，我们每个人的朋友交际圈就是一个巨大的「图」。



图 1. 小A的朋友交际图

在上面「小A的朋友交际图」中，我们可以看到小 A 和小 G 、小 B 、小 E 都是直接的朋友，而小 A 和小 C 、小 D 、小 F 都是间接的朋友。这就是一个小 A 的朋友交际图。那么「图」在数据结构中到底是什么呢？

「图」的类型
「图」的类型有很多，本 Leetbook 中我们将介绍三种类型的图：无向图、有向图、加权图。

无向图
「无向图」的图中任意两个顶点之间的边都是没有方向的。

「图1. 小A的朋友交际图」是一个无向图。

有向图
「有向图」的图中任意两个顶点之间的边都是有方向的。

「图 2. 有向图的示例图」是一个有向图。



图 2. 有向图的示例图

加权图
「加权图」的图中的每条边都带有一个相关的权重。这里的权重可以是任何一种度量，比如时间，距离，尺寸等。生活中最常见的「加权图」应该就是我们的地图了。在下方的「图 3. 加权图的示例图」中，每条边上都标有距离，它们可以视为每个边上的权重。



图 3. 加权图的示例图

「图」的定义和相关术语
「图」是由顶点和边组成的一种非线形数据结构。在「图」中有很多相关术语来描述一个图。在本 Leetbook 中，如果在后面的学习中遇到不认识的术语，请回到这里查看相关的定义。

顶点：在「图 1. 小A的朋友交际图」中，小 A 、小 B 、小 C 等均称为「图」的顶点。
边：顶点之间的连接线称为边。在「图 1. 小A的朋友交际图」中，小 A 和小 B 之间的连接线就是图中的一条边。
路径：从一个顶点到另一个顶点之间经过的所有顶点的集合。在「图 1. 小A的朋友交际图」中，从小 A 到小 C 的路径为[小A, 小B, 小C] 或者[小A, 小G, 小B, 小C]或者[小A, 小E, 小F, 小D, 小B, 小C]。
**注意：**两个顶点之间的路径可以是很多条。
路径长度：一条路径上经过的边的数量。在「图 1. 小A的朋友交际图」中，从小 A 到小 C 的路径长度为2或者3或者5。
环：起点和终点为同一个顶点的路径。在「图 1. 小A的朋友交际图」中，[小A, 小B, 小D, 小F, 小E]组成了一个环。同理，[小A, 小G, 小B]也组成了一个环。
负权环：在「加权图」中，如果一个环的所有边的权重加起来为负数，我们就称之为「负权环」。在「图4. 负权环」中，它的所有边的权重和为-3。
连通性：两个不同顶点之间存在至少一条路径，则称这两个顶点是连通的。在「图 1. 小A的朋友交际图」中，小 A 和小 C 是连通的，因为它们之间至少有一条路径。
顶点的度：「度」适用于无向图，指的是和该顶点相连接的所有边数称为顶点的度。在「图 1. 小A的朋友交际图」中，顶点小A的度为3，因为与它相连接的边有3条。
顶点的入度：「入度」适用于有向图，一个顶点的入度为dd，则表示有dd条与顶点相连的边指向该顶点。在「图 2. 有向图的示例图」中，A的入度为1，由F指向A的边。
顶点的出度：「出度」适用于有向图，它与「入度」相反。一个顶点的出度为dd，则表示有dd条与顶点相连的边以该顶点为起点。在「图 2. 有向图的示例图」中，A 的出度为3，分别为，A 指向 B 的边，A 指向 C 的边，和 A 指向 G 的边。


图 4. 负权环

在了解了「图」的基本知识之后，就让我们来开启与「图」相关的数据结构和算法旅程吧！

在接下来的章节中，你将了解到：

并查集（ Union Find ）数据结构
「图」的深度优先搜索算法
「图」的广度优先搜索算法
最小生成树相关定理和算法
切分定理
Kruskal 算法
Prim 算法
单源最短路径相关算法
Dijkstra 算法
Bellman-Ford 算法
拓扑排序之 Kahn 算法


Quick Find 的「并查集」
Quick Find的工作原理

时间复杂度
UnionFind 构造函数	find 函数	union 函数	connected 函数
时间复杂度	O(N)O(N)	O(1)O(1)	O(N)O(N)	O(1)O(1)
注：NN 为「图」中顶点的个数。



按秩合并的「并查集」
小伙伴看到这里的时候，我们其实已经实现了 2 种「并查集」。但它们都有一个很大的缺点，这个缺点就是通过 union 函数连接顶点之后，可能所有顶点连成一条线形成「图 5. 一条线的图」，这就是我们 find 函数在最坏的情况下的样子。那么我们有办法解决吗？

当然，伟大的科学家已经给出了解决方案，就是按秩合并。这里的「秩」可以理解为「秩序」。之前我们在 union 的时候，我们是随机选择 x 和 y 中的一个根节点/父节点作为另一个顶点的根节点。但是在「按秩合并」中，我们是按照「某种秩序」选择一个父节点。

这里的「秩」指的是每个顶点所处的高度。我们每次 union 两个顶点的时候，选择根节点的时候不是随机的选择某个顶点的根节点，而是将「秩」大的那个根节点作为两个顶点的根节点，换句话说，我们将低的树合并到高的树之下，将高的树的根节点作为两个顶点的根节点。这样，我们就避免了所有的顶点连成一条线，这就是按秩合并优化的「并查集」。




「图」的深度优先搜索算法
在前面的「并查集」数据结构中，大家已经知道如何检查两个顶点之间的连通性。那如果给你一个「图」，你该如何找出它所有的顶点呢？
以及你又如何找出它两个顶点之间的所有路径呢？此时，「深度优先搜索」算法就可以登场了。
如「图6. 无向图」所示，它的所有顶点分别为[A, C, D, B, E]。给定顶点 A 和 B， 它们之间有两条路径，一条路径为[A, C, D, B]，另一条路径为[A, E, B]。



图 6. 无向图

「深度优先搜索」（又称「Depth First Search」，简称「DFS」）算法在「图」中主要用途：

遍历「图」中所有顶点；
遍历「图」中任意两点之间的所有路径。


遍历所有顶点 - 深度优先搜索算法
视频讲解

时间复杂度
O(V+E)O(V+E)。

VV 表示顶点数，EE 表示边数。

空间复杂度
O(V)O(V)。

VV 表示顶点数。



遍历两点之间所有路径 - 深度优先搜索算法
视频讲解

时间复杂度
O((2^V)*(V+E))O((2 
V
 )∗(V+E))。

VV 表示顶点数，EE 表示边数。

空间复杂度
O((2^V)*V)O((2 
V
 )∗V)。
 
 
 
 「图」的广度优先搜索算法
 既然我们之前已经提及了「深度优先搜索」算法了，那么作为它的兄弟算法「广度优先遍历」算法，我们就不得不提了。「广度优先搜索」算法不仅可以遍历「图」的所有顶点，也可以遍历两个顶点的所有路径。
 但是，「广度优先搜索」最高效的用途是：当在 权重相等且均为正数的「图」 中，它可以快速的找到两点之间的最短路径。
 
 虽然「深度优先搜索」算法也可以针对权重相等均且为正数的「图」找出两点之间的最短路径，但它需要先找出两点之间的所有路径之后，才可以求出最短路径。
 但是对于「广度优先搜索」，在大多数情况下，它可以不用找出所有路径，就能取出两点之间的最短路径。
 除非，最短路径出现在最后一条遍历的路径上，这种情况下，「广度优先搜索」也是遍历出了所有路径后，才取出的最短路径。
 
 如「图7. 无向图」所示，它的所有顶点分别为[A, C, D, B, E]。给定顶点 A 和 B， 它们之间有两条路径，一条路径为[A, C, D, B]，另一条路径为[A, E, B]。其中，[A, E, B]是顶点 A 和 B 之间的最短路径。
 
 
 
 图 7. 无向图
 
 「广度优先遍历」（又称「Breath First Search」，简称「BFS」）算法在「图」中主要用途：
 
 遍历「图」中所有顶点；
 针对 权重相等且均为正数的「图」，快速找出两点之间的最短路径。
 
