Introduction:
skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）

一般用于解决查找问题的数据结构分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面


Comparing with BTree and HashTable:
skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。 所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点
在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现
平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速
从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势
查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的


从算法实现难度上来比较，skiplist比平衡树要简单得多


跳表查找任意数据的时间复杂度为O(logn)
跳表的空间复杂度为O(n)
跳表的插入、删除操作时间复杂度为：O(logn)，支持动态的删除。


当我们希望快速存取<Key, Value>键值对时我们可以使用HashMap。
        当我们希望在多线程并发存取<Key, Value>键值对时，我们会选择ConcurrentHashMap。
        TreeMap则会帮助我们保证数据是按照Key的自然顺序或者compareTo方法指定的排序规则进行排序。
        OK，那么当我们需要多线程并发存取<Key, Value>数据并且希望保证数据有序时，我们需要怎么做呢？
        也许，我们可以选择ConcurrentTreeMap。不好意思，JDK没有提供这么好的数据结构给我们。
        当然，我们可以自己添加lock来实现ConcurrentTreeMap，但是随着并发量的提升，lock带来的性能开销也随之增大。
        Don't cry......，JDK6里面引入的ConcurrentSkipListMap也许可以满足我们的需求。
        什么是ConcurrentSkipListMap
        ConcurrentSkipListMap提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够O(log(n))时间内完成查找、插入、删除操作。
        存储结构
        ConcurrentSkipListMap存储结构跳跃表（SkipList）：
        1、最底层的数据节点按照关键字升序排列。
        2、包含多级索引，每个级别的索引节点按照其关联数据节点的关键字升序排列。
        3、高级别索引是其低级别索引的子集。
        4、如果关键字key在级别level=i的索引中出现，则级别level<=i的所有索引中都包含key。